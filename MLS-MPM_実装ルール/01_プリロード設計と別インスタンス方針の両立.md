# 質問1: プリロードで「全シーンrender」する設計は、別インスタンス方針と両立するか？

## 回答

### ✅ **両立可能だが、安全条件が必要**

---

## 安全条件

### 条件1: **confの読み取りタイミングを固定**

- `MlsMpmSimulator.init()` 内で `conf.maxParticles` を読み取るタイミングを、**setup()時点で一度だけ**にする
- プリロード時のrender()実行中に `conf.particles` を変更しない
- シーン固有のパラメータは、**setup()時にconfから読み取ってシーン内に保存**する

### 条件2: **プリロード時のrender()は「シェーダーコンパイルのみ」を目的とする**

- プリロード時のrender()では、**シミュレーションのupdate()を呼ばない**
- または、update()を呼ぶ場合は、**confの変更を伴わない**ことを保証する

### 条件3: **各シーンのMlsMpmSimulatorは独立したバッファを持つ**

- プリロード時に全シーンでrender()を実行しても、**各シーンのparticleBuffer/cellBufferは独立**している
- ただし、**confへの依存があるため、confの変更が全シーンに影響する**点に注意

---

## 代替案（より安全）

プリロード時のrender()を**スキップ**し、代わりに：

- **シェーダーコンパイルのみを明示的に実行**する（compute pipelineの作成）
- または、**初回シーン切り替え時にのみシェーダーコンパイル**を実行する（若干の遅延は許容）

---

## 実装上の注意点

### SceneManager.preloadAllScenes()での実装

```javascript
async preloadAllScenes() {
  for (let i = 0; i < this.scenes.length; i++) {
    const s = this.scenes[i];
    
    // setup()実行（confから読み取ってシーン内に保存される）
    await s.setup();
    
    // プリロード時のrender()は「シェーダーコンパイルのみ」を目的とする
    // → update()は呼ばない、またはconfを変更しないことを保証
    if (shouldChangeIndex) {
      this.currentSceneIndex = i;
    }
    if (s.setResourceActive) {
      s.setResourceActive(true);
    }
    
    // render()実行（シェーダーコンパイル）
    if (s.render) {
      await s.render();
    }
    
    // 非アクティブ化（バッファは保持）
    if (s.setResourceActive) {
      s.setResourceActive(false);
    }
    
    // currentSceneIndexを復元
    if (shouldChangeIndex) {
      this.currentSceneIndex = tempSceneIndex;
    }
  }
}
```

### 必須ルール

1. **setup()時にconfから読み取ってシーン内に保存**
   - シーン固有のパラメータは、シーン内の変数に保存
   - MlsMpmParticleSystem.init()にparamsを渡す

2. **プリロード時のrender()ではconfを変更しない**
   - update()を呼ぶ場合は、confの変更を伴わないことを保証
   - シェーダーコンパイルのみを目的とする

3. **各シーンのMlsMpmSimulatorは独立したバッファを持つ**
   - プリロード時に全シーンでrender()を実行しても、各シーンのparticleBuffer/cellBufferは独立している

---

## まとめ

- **方針**: プリロードで全シーンrenderは両立可能
- **安全条件**: setup()時にconfから読み取ってシーン内に保存、プリロード時のrender()ではconfを変更しない
- **実装**: SceneManager.preloadAllScenes()で上記の安全条件を守る
